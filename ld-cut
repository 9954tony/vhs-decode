#!/usr/bin/env python3
from base64 import b64encode
import copy
from datetime import datetime
import getopt
import io
from io import BytesIO
import os
import signal
import sys
import argparse
import json
import traceback
import subprocess

from lddecode.core import *
from lddecode.utils import *

parser = argparse.ArgumentParser(description='Extract a sample area from raw RF laserdisc captures.  (Similar to ld-decode, except it outputs samples)')
parser.add_argument('infile', metavar='infile', type=str, help='source file')
parser.add_argument('outfile', metavar='outfile', type=str, help='destination file (recommended to use .lds suffix)')

parser.add_argument('-s', '--start', metavar='start', type=float, default=0, help='rough jump to frame n of capture (default is 0)')
parser.add_argument('-l', '--length', metavar='length', type=int, default = -1, help='limit length to n frames')

parser.add_argument('-S', '--seek', metavar='seek', type=int, default=-1, help='seek to frame n of capture')
parser.add_argument('-E', '--end', metavar='end', type=int, default=-1, help='cutting: last frame')

parser.add_argument('-p', '--pal', dest='pal', action='store_true', help='source is in PAL format')
parser.add_argument('-n', '--ntsc', dest='ntsc', action='store_true', help='source is in NTSC format')
parser.add_argument('-C', '--ldf-compression-level', dest='ldfcomp', type=int, default=11, help='compression level for .ldf files')

args = parser.parse_args()

#print(args)
filename = args.infile
outname = args.outfile

vid_standard = 'PAL' if args.pal else 'NTSC'

if args.pal and args.ntsc:
    print("ERROR: Can only be PAL or NTSC")
    exit(1)

try:
    loader = make_loader(filename, None)
except ValueError as e:
    print(e)
    exit(1)

makelds = True if outname[-3:] == 'lds' else False
makeldf = True if outname[-3:] == 'ldf' else False
    
system = 'PAL' if args.pal else 'NTSC'

# Wrap the LDdecode creation so that the signal handler is not taken by sub-threads,
# allowing SIGINT/control-C's to be handled cleanly
original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
ldd = LDdecode(filename, None, loader, system=system, doDOD = False)
signal.signal(signal.SIGINT, original_sigint_handler)

if args.seek != -1:
    startloc = ldd.seek(args.start, args.seek) 
    if startloc is None:
        print("ERROR: Seeking failed")
        exit(1)
    elif startloc > 1:
        startloc -= 1
else:
    startloc = args.start * 2

if args.end != -1:
    endloc = ldd.seek(startloc, args.end)
    if endloc is None:
        print("ERROR: Seeking failed")
        exit(1)
elif args.length != -1:
    endloc = startloc + (args.length * 2)
else:
    print('ERROR: Must specify -l or -E option')
    exit(-1)

ldd.roughseek(startloc)
startidx = int(ldd.fdoffset)

ldd.roughseek(endloc)
endidx = int(ldd.fdoffset)

if makelds:
    process = subprocess.Popen(['ld-lds-converter', '-o', outname, '-p'], stdin=subprocess.PIPE)
    fd = process.stdin
elif makeldf:
    corecmd = "ffmpeg -y -hide_banner -loglevel error -f s16le -ar 40k -ac 1 -i - -acodec flac -f ogg".split(' ') 
    process = subprocess.Popen([*corecmd, '-compression_level', str(args.ldfcomp), outname], stdin=subprocess.PIPE)
    fd = process.stdin
else:
    fd = open(args.outfile, 'wb')

#print(startloc, endloc, startidx, endidx)

for i in range(startidx, endidx + 16384, 16384):
    l = endidx - i

    if l > 16384:
        l = 16384
    else:
        break
    #l = 16384 if (l > 16384) else l

    data = ldd.freader(ldd.infile, i, l)
    dataout = np.array(data, dtype=np.int16)

    fd.write(dataout)

fd.close()

if makelds:
    # allow ld-lds-converter to finish after EOFing it's input
    process.wait()
    
#exit(0)
