
#include <iostream>
#include <string.h>
#include "ld-decoder.h"
#include "deemp.h"

using namespace std;

// taken directly from ECMA-130, with last two values from http://www.laesieworks.com/digicom/Storage_CD_8to14.html
unsigned int efm[] = {
    0b01001000100000,
    0b10000100000000,
    0b10010000100000,
    0b10001000100000,
    0b01000100000000,
    0b00000100010000,
    0b00010000100000,
    0b00100100000000,
    0b01001001000000,
    0b10000001000000,
    0b10010001000000,
    0b10001001000000,
    0b01000001000000,
    0b00000001000000,
    0b00010001000000,
    0b00100001000000,
    0b10000000100000,
    0b10000010000000,
    0b10010010000000,
    0b00100000100000,
    0b01000010000000,
    0b00000010000000,
    0b00010010000000,
    0b00100010000000,
    0b01001000010000,
    0b10000000010000,
    0b10010000010000,
    0b10001000010000,
    0b01000000010000,
    0b00001000010000,
    0b00010000010000,
    0b00100000010000,
    0b00000000100000,
    0b10000100001000,
    0b00001000100000,
    0b00100100100000,
    0b01000100001000,
    0b00000100001000,
    0b01000000100000,
    0b00100100001000,
    0b01001001001000,
    0b10000001001000,
    0b10010001001000,
    0b10001001001000,
    0b01000001001000,
    0b00000001001000,
    0b00010001001000,
    0b00100001001000,
    0b00000100000000,
    0b10000010001000,
    0b10010010001000,
    0b10000100010000,
    0b01000010001000,
    0b00000010001000,
    0b00010010001000,
    0b00100010001000,
    0b01001000001000,
    0b10000000001000,
    0b10010000001000,
    0b10001000001000,
    0b01000000001000,
    0b00001000001000,
    0b00010000001000,
    0b00100000001000,
    0b01001000100100,
    0b10000100100100,
    0b10010000100100,
    0b10001000100100,
    0b01000100100100,
    0b00000000100100,
    0b00010000100100,
    0b00100100100100,
    0b01001001000100,
    0b10000001000100,
    0b10010001000100,
    0b10001001000100,
    0b01000001000100,
    0b00000001000100,
    0b00010001000100,
    0b00100001000100,
    0b10000000100100,
    0b10000010000100,
    0b10010010000100,
    0b00100000100100,
    0b01000010000100,
    0b00000010000100,
    0b00010010000100,
    0b00100010000100,
    0b01001000000100,
    0b10000000000100,
    0b10010000000100,
    0b10001000000100,
    0b01000000000100,
    0b00001000000100,
    0b00010000000100,
    0b00100000000100,
    0b01001000100010,
    0b10000100100010,
    0b10010000100010,
    0b10001000100010,
    0b01000100100010,
    0b00000000100010,
    0b01000000100100,
    0b00100100100010,
    0b01001001000010,
    0b10000001000010,
    0b10010001000010,
    0b10001001000010,
    0b01000001000010,
    0b00000001000010,
    0b00010001000010,
    0b00100001000010,
    0b10000000100010,
    0b10000010000010,
    0b10010010000010,
    0b00100000100010,
    0b01000010000010,
    0b00000010000010,
    0b00010010000010,
    0b00100010000010,
    0b01001000000010,
    0b00001001001000,
    0b10010000000010,
    0b10001000000010,
    0b01000000000010,
    0b00001000000010,
    0b00010000000010,
    0b00100000000010,
    0b01001000100001,
    0b10000100100001,
    0b10010000100001,
    0b10001000100001,
    0b01000100100001,
    0b00000000100001,
    0b00010000100001,
    0b00100100100001,
    0b01001001000001,
    0b10000001000001,
    0b10010001000001,
    0b10001001000001,
    0b01000001000001,
    0b00000001000001,
    0b00010001000001,
    0b00100001000001,
    0b10000000100001,
    0b10000010000001,
    0b10010010000001,
    0b00100000100001,
    0b01000010000001,
    0b00000010000001,
    0b00010010000001,
    0b00100010000001,
    0b01001000000001,
    0b10000010010000,
    0b10010000000001,
    0b10001000000001,
    0b01000010010000,
    0b00001000000001,
    0b00010000000001,
    0b00100010010000,
    0b00001000100001,
    0b10000100001001,
    0b01000100010000,
    0b00000100100001,
    0b01000100001001,
    0b00000100001001,
    0b01000000100001,
    0b00100100001001,
    0b01001001001001,
    0b10000001001001,
    0b10010001001001,
    0b10001001001001,
    0b01000001001001,
    0b00000001001001,
    0b00010001001001,
    0b00100001001001,
    0b00000100100000,
    0b10000010001001,
    0b10010010001001,
    0b00100100010000,
    0b01000010001001,
    0b00000010001001,
    0b00010010001001,
    0b00100010001001,
    0b01001000001001,
    0b10000000001001,
    0b10010000001001,
    0b10001000001001,
    0b01000000001001,
    0b00001000001001,
    0b00010000001001,
    0b00100000001001,
    0b01000100100000,
    0b10000100010001,
    0b10010010010000,
    0b00001000100100,
    0b01000100010001,
    0b00000100010001,
    0b00010010010000,
    0b00100100010001,
    0b00001001000001,
    0b10000100000001,
    0b00001001000100,
    0b00001001000000,
    0b01000100000001,
    0b00000100000001,
    0b00000010010000,
    0b00100100000001,
    0b00000100100100,
    0b10000010010001,
    0b10010010010001,
    0b10000100100000,
    0b01000010010001,
    0b00000010010001,
    0b00010010010001,
    0b00100010010001,
    0b01001000010001,
    0b10000000010001,
    0b10010000010001,
    0b10001000010001,
    0b01000000010001,
    0b00001000010001,
    0b00010000010001,
    0b00100000010001,
    0b01000100000010,
    0b00000100000010,
    0b10000100010010,
    0b00100100000010,
    0b01000100010010,
    0b00000100010010,
    0b01000000100010,
    0b00100100010010,
    0b10000100000010,
    0b10000100000100,
    0b00001001001001,
    0b00001001000010,
    0b01000100000100,
    0b00000100000100,
    0b00010000100010,
    0b00100100000100,
    0b00000100100010,
    0b10000010010010,
    0b10010010010010,
    0b00001000100010,
    0b01000010010010,
    0b00000010010010,
    0b00010010010010,
    0b00100010010010,
    0b01001000010010,
    0b10000000010010,
    0b10010000010010,
    0b10001000010010,
    0b01000000010010,
    0b00001000010010,
    0b00010000010010,
    0b00100000010010,
    0b00100000000001, // 1st Frame, byte 0, called SYNC 0
    0b00000000010010  // 2nd Frame, byte 0, called SYNC 1
};

// actually signed short int, but we want an extra bit for ?able bytes
int dsbuf[3][12]; 

// descrambling is rather non-linear, so we handle each sample separately.
int * descramble(unsigned short inbuf[28])
{
	memmove(dsbuf[0], dsbuf[1], 12 * 4 * 2);
	
	dsbuf[0][0] = (inbuf[0] << 8) + inbuf[1];
	dsbuf[0][1] = (inbuf[6] << 8) + inbuf[7];
	dsbuf[2][2] = (inbuf[16] << 8) + inbuf[17];
	dsbuf[2][3] = (inbuf[22] << 8) + inbuf[23];
	dsbuf[0][4] = (inbuf[2] << 8) + inbuf[3];
	dsbuf[0][5] = (inbuf[8] << 8) + inbuf[9];
	dsbuf[2][6] = (inbuf[18] << 8) + inbuf[19];
	dsbuf[2][7] = (inbuf[24] << 8) + inbuf[25];
	dsbuf[0][8] = (inbuf[4] << 8) + inbuf[5];
	dsbuf[0][9] = (inbuf[10] << 8) + inbuf[11];
	dsbuf[2][10] = (inbuf[20] << 8) + inbuf[21];
	dsbuf[2][11] = (inbuf[26] << 8) + inbuf[27];

	return (int *)dsbuf;
}

unsigned short c2buf[108][32];

void c2_proc(unsigned short inbuf[28])
{
	memmove(c2buf[0], c2buf[1], 28 * 2 * 107);

	for (int i = 0; i < 28; i++) {
		c2buf[(27 - i) * 4][i] = inbuf[i];
	}

	// error correction goes here

	descramble(c2buf[0]);
}

// bits 0-7 are the bytes, bit 8 is error flag
unsigned short c1buf[2][32];

void c1_proc(unsigned char input[32])
{
	memcpy(c1buf[0], c1buf[1], 32 * 2);

	// delay every odd byte by one frame	
	for (int i = 0; i < 32; i += 2) {
		c1buf[0][i] = input[i];
		c1buf[1][i + 1] = input[i + 1];
	}

	// invert parity symbols
	for (int i = 12; i < 16; i++) {
		c1buf[0][i] ^= 0xff;
		c1buf[0][i + 16] ^= 0xff;
	} 

	// todo:  check parity

	c2_proc((unsigned short *)c1buf[0]);
}

// http://www.dspguru.com/dsp/howtos/how-to-interpolate-fft-peak
double quadfit(double a, double b, double c)
{
	double y1 = fabs(a);
	double y2 = fabs(b);
	double y3 = fabs(c);

//	printf("%lf %lf %lf %lf\n", b - a, t, b - c, (b - c) / t);
	double d = (y3 - y1) / (2 * (2 * y2 - y1 - y3));
//	printf("%lf %lf %lf %lf %lf %lf\n", y1, y2, y3, y3 - y1, y1 + y2 + y3, d);

//	d=(y1-y3)/((2*y2)-y1-y3);

	return d;
}

// quinn's second estimator - doesn't seem to work for this
double tau(double x) 
{
	return 0.25 * log((3*(x * x)) + (6 * x) + 1) - (sqrt(6.0)/24.0) * log((x + 1 - sqrt(2.0/3.0))  /  (x + 1 + sqrt(2.0/3.0)));
}

double quinn2(double y1, double y2, double y3)
{
	double ap = (y3 * y2)  /  (y2 * y2);
	double dp = -ap / (1 - ap);

	double am = (y1 * y2)  /  (y2 * y2);
	double dm = am / (1 - am);

	double d = (dp + dm) / 2 + tau(dp * dp) - tau(dm * dm);

	printf("%lf %lf : %lf %lf : %lf\n", ap, dp, am, dm, d);

	return d;
}


int procbuf(unsigned char *buf, int len)
{
	double fbuf[len];
	double tot = 0;
	Filter filt(f_efm8);
	int i;

	if (len < 4096) return -1;

	for (i = 0; i < len; i++) {
		fbuf[i] = filt.feed(buf[i]);
		tot += fbuf[i];
	}

	double avg = tot / len;	
	for (i = 0; i < len; i++) {
		fbuf[i] -= avg;
	}

	double err = 0;
	double prev = 128.0;
	for (i = 128; i < (len - 12); i++) {
		double c = fbuf[i];

		if (((c > fbuf[i - 6]) && (c > fbuf[i + 6]) && (c > fbuf[i - 1]) && (c > fbuf[i + 1])) ||  
		    ((c < fbuf[i - 6]) && (c < fbuf[i + 6]) && (c < fbuf[i - 1]) && (c < fbuf[i + 1]))) {  
			if ((i - prev) > 14) {
				double lin = quadfit(fbuf[i - 1], fbuf[i], fbuf[i + 1]) + i - 0.0;
//				lin = i;
				double count = (lin - prev) / (28.63636 / 4.3218);
				double _err = fabs(count - floor(count + .5));
				err += (_err * _err);
				printf("%lf %d %lf %lf %lf %lf %lf %lf %lf %lf %lf\n", err, i, lin, prev, lin - prev, (lin - prev) / (28.636 / 4.30), fbuf[i - 2], fbuf[i - 1], fbuf[i], fbuf[i + 1], fbuf[i + 2]);
				prev = lin;
			}
		}
	}

	return 0;
}

// at 8x fsc one frame is about 3300 bytes, so 10k is enough to always have a whole frame
// even after filtering
const int blocklen = 16384;
int inbuf = 0;

unsigned char buf[blocklen];

int main(void)
{

	while (1) {
		while (blocklen - inbuf) {
			ssize_t rv = read(0, &buf[inbuf], blocklen - inbuf);
			if (rv < 0) return 0; 

			inbuf += rv;
		};

		procbuf(buf, blocklen);
		return 0;
	}

	return 0;
}


