/************************************************************************

    filter.h

    ld-efm-sampletodata - EFM sample to data processor for ld-decode
    Copyright (C) 2019 Simon Inns

    This file is part of ld-decode-tools.

    ld-efm-sampletodata is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

************************************************************************/

#ifndef FILTER_H
#define FILTER_H

#include <QCoreApplication>
#include <QDebug>

class Filter
{
public:
    Filter();

    QVector<qint16> dcBlocking(QVector<qint16> x);
    QVector<qint16> channelEqualizer(QVector<qint16> inputSample);

private:
    // Channel equalizer filter ---------------------------------------------------------------------------------------

    // M = Amount of over sampling
    // D = Number of symbols to be spanned by the impulse response
    // N = D * M (where both M and D are integers)
    //
    // Oversampling is 40,000,000 / 4321800 = 9.25
    // Best if D and M are integer multiples
    //
    // N = 9 * 9 = 81 taps

    // Generated by:   http://www-users.cs.york.ac.uk/~fisher/mkfilter
    //   filtertype 	= 	Raised Cosine
    //   samplerate 	= 	40000000
    //   corner 	= 	4321800
    //   beta 	= 	0.25
    //   impulselen 	= 	81
    //   racos 	= 	yes
    //   comp 	= 	no
    //   bits 	=
    //   logmin 	=

    /* Digital filter designed by mkfilter/mkshape/gencode   A.J. Fisher
       Command line: /www/usr/fisher/helpers/mkshape -c 1.0804500000e-01 2.5000000000e-01 81 -l */

    static const qint32 ceNZeros = 80;
    static constexpr qreal ceGain = 4.625153248e+00;
    qreal ceXv[ceNZeros+1];

    const qreal ceXcoeffs[ceNZeros+1] = {
        -0.0016403018, -0.0020733434, -0.0014862022, +0.0000389990,
        +0.0018235484, +0.0029214769, +0.0026792881, +0.0011827360,
        -0.0007309920, -0.0019680351, -0.0019087629, -0.0008897278,
        -0.0000404568, -0.0004681871, -0.0022617489, -0.0040358449,
        -0.0035312793, +0.0008406637, +0.0083417111, +0.0153142773,
        +0.0164671532, +0.0078368465, -0.0099588432, -0.0301920458,
        -0.0417827879, -0.0343608216, -0.0046688895, +0.0390100095,
        +0.0775212843, +0.0877329814, +0.0537121700, -0.0224798197,
        -0.1159000783, -0.1834996141, -0.1783692546, -0.0687686530,
        +0.1456798365, +0.4280266929, +0.7120428655, +0.9224197674,
        +1.0000000127, +0.9224197674, +0.7120428655, +0.4280266929,
        +0.1456798365, -0.0687686530, -0.1783692546, -0.1834996141,
        -0.1159000783, -0.0224798197, +0.0537121700, +0.0877329814,
        +0.0775212843, +0.0390100095, -0.0046688895, -0.0343608216,
        -0.0417827879, -0.0301920458, -0.0099588432, +0.0078368465,
        +0.0164671532, +0.0153142773, +0.0083417111, +0.0008406637,
        -0.0035312793, -0.0040358449, -0.0022617489, -0.0004681871,
        -0.0000404568, -0.0008897278, -0.0019087629, -0.0019680351,
        -0.0007309920, +0.0011827360, +0.0026792881, +0.0029214769,
        +0.0018235484, +0.0000389990, -0.0014862022, -0.0020733434,
        -0.0016403018,
      };

    // Method prototypes ----------------------------------------------------------------------------------------------
    qreal channelEqualizerFir(qreal inputSample);
};

#endif // FILTER_H
